item_palette_defaulter = [
    # So normally, item pickup sprites in the game have a choice of either using a palette that the game always keeps
    # loaded, or a custom one that is dynamically loaded in with the item sprite. Up to two custom item palettes can be
    # loaded at once, and if the game tries loading a third item with a third distinct custom palette that's not already
    # being used by something else at that point, the item will despawn instantly. This can be quite problematic in
    # rooms that have more than 2 location checks inside them, so to """""fix""""" the issue, this hack will, instead of
    # despawn the item, switch its palette to the always-loaded OBP1 one. The item will look weird, but it's still
    # better than any potential seed softlock scenarios that may arise from the alternative...
    0x02, 0x16,  # asr r2, r0, 18
    0xFF, 0x21,  # mov r1, 0xFF
    0x11, 0x40,  # and r1, r2
    0xFF, 0x20,  # mov r0, 0xFF
    0x88, 0x42,  # cmp r0, r1
    0x00, 0xD1,  # bne [forward 0x01]
    0x01, 0x22,  # mov r2, 0x01
    0x00, 0x2F,  # cmp r7, 0x00
    0x02, 0xDB,  # blt [forward 0x03]
    0x00, 0x2A,  # cmp r2, 0x00
    0x01, 0x48,  # ldr  r0, 0x80197D8
    0x00, 0xE0,  # b   [forward 0x01]
    0x01, 0x48,  # ldr  r0, 0x80197DA
    0x87, 0x46,  # mov  r15, r0
    # LDR number pool
    0xD8, 0x97, 0x01, 0x08,
    0xDA, 0x97, 0x01, 0x08,
]


extras_unlocker = [
    # On the Konami logo screen, this will set all flags in the save file (in both EWRAM and SRAM) that unlock all
    # postgame extras. Including Boss Rush; playable Maxim; hard mode; and, most importantly, the ability to skip all
    # cutscenes.
    0xC2, 0x21,  # mov r1, 0xC2
    0x01, 0x60,  # str r1, [r0]
    0x02, 0x48,  # ldr r0, 0xE000BF8
    0x01, 0x60,  # str r1, [r0]
    0x00, 0x48,  # ldr r0, 0x8001FFC
    0x87, 0x46,  # mov r15, r0
    # LDR number pool
    0xFC, 0x1F, 0x00, 0x08,
    0xF8, 0x0B, 0x00, 0x0E,
]


remote_textbox_shower = [
    # Pops up the textbox(s) of whatever textbox IDs is written at 0x02018A00 and 0x02018A02 and increments the current
    # received item index at 0x02028862 if a number to increment it by is written at 0x02018A04. Also plays the sound
    # effect of the ID written at 0x02018A06, if one is written there. The halfword at 0x02018A08 is a frame delay timer
    # for any situations wherein it'd be unsafe to trigger any of this stuff, and the byte at 0x02018A0A is used to tell
    # whether there is a center-screen textbox that should be cleared or not.
    #
    # This will NOT give any items on its own; the item has to be written by the client into the inventory alongside
    # writing the above-mentioned things.

    # Run the function that checks to see if the player is on top of a loading zone. If they are, skip doing any more of
    # this.
    0x40, 0x18,  # add  r0, r0, r1
    0x00, 0x68,  # ldr  r0, [r0]
    0x40, 0x4A,  # ldr  r2, 0x800AF38
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # add  r3, 0x05
    0x9E, 0x46,  # mov  r14, r3
    0x97, 0x46,  # mov  r15, r2
    0x31, 0xB4,  # push r0, r4, r5
    0x00, 0x28,  # cmp  r0, 0x00
    0x03, 0xD1,  # bne [forward 0x04]
    # If we were in a loading zone, un-prime the center textbox for deletion. The textbox wll have been auto-deleted
    # upon room transitioning by the next time this runs. This is more likely to occur while going through a door.
    0x34, 0x48,  # ldr  r0, 0x2018A00
    0x00, 0x21,  # mov  r1, 0x00
    0x81, 0x72,  # strb r1, [r0, 0x0A]
    0x62, 0xE0,  # b    [forward 0x63]
    # Check the current menu state to make sure it's safe to call a textbox and that we are not in a room transition
    # or something else that would cause problems. If it's not safe, skip running anything else here.
    0x39, 0x4A,  # ldr  r2, 0x2000048
    0x13, 0x78,  # ldrb r3, [r2]
    0x01, 0x2B,  # cmp  r3, 0x01
    0x5E, 0xD1,  # bne [forward 0x5F]
    # Check the "on-screen textbox" byte to see if the 0x01 or 0x02 bit is set. If either is, we are looking at a
    # textbox or max up graphic and Juste should be frozen in place.
    0x39, 0x4A,  # ldr  r2, 0x2000000
    0x03, 0x20,  # mov  r0, 0x03
    0xD3, 0x7B,  # ldrb r3, [r2, 0x0F]
    0x03, 0x40,  # and  r3, r0
    0x00, 0x2B,  # cmp  r3, 0x00
    0x58, 0xD1,  # bne  [forward 0x59]
    # Check the "in control of player" byte to make sure we are not in a cutscene or saving.
    0xD3, 0x7E,  # ldrb r3, [r2, 0x1B]
    0x00, 0x2B,  # cmp  r3, 0x00
    0x55, 0xD1,  # bne  [forward 0x56]
    # Check the "delay" timer buffer for a non-zero. If it is, decrement it by one and skip straight to the return part
    # of this code, as we may have received an item on a frame wherein it's "unsafe" to pop the item textboxes.
    0x2C, 0x4A,  # ldr  r2, 0x2018A00
    0x13, 0x89,  # ldrh r3, [r2, 0x08]
    0x00, 0x2B,  # cmp  r2, 0x00
    0x02, 0xD0,  # beq  [forward 0x03]
    0x01, 0x3B,  # sub  r3, 0x01
    0x13, 0x81,  # strh r3, [r2, 0x08]
    0x4E, 0xE0,  # b    [forward 0x4F]
    # Run the "clear center-screen textbox" function if our "primed" byte for it is set.
    0x28, 0x48,  # ldr  r0, 0x2018A00
    0x81, 0x7A,  # ldrb r1, [r0, 0x0A]
    0x00, 0x29,  # cmp  r1, 0x00
    0x09, 0xD0,  # beq  [forward 0x0A]
    0x0E, 0x20,  # mov  r0, 0x0E
    0x01, 0x21,  # mov  r1, 0x01
    0x2B, 0x4A,  # ldr  r2, 0x802B5DC
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # add  r3, 0x05
    0x9E, 0x46,  # mov  r14, r3
    0x97, 0x46,  # mov  r15, r2
    0x23, 0x48,  # ldr  r0, 0x2018A00
    0x00, 0x21,  # mov  r1, 0x00
    0x81, 0x72,  # strb r1, [r0, 0x0A]
    # Check our bottom-left corner textbox buffer for a non-zero number. If we have one, run the "display bottom-left
    # blue corner textbox" function with that number in r0.
    0x00, 0x88,  # ldrh r0, [r0]
    0x00, 0x28,  # cmp  r0, 0x00
    0x0C, 0xD0,  # beq  [forward 0x0D]
    0x21, 0x4A,  # ldr  r2, 0x8008980
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # add  r3, 0x05
    0x9E, 0x46,  # mov  r14, r3
    0x97, 0x46,  # mov  r15, r2
    # Run the "update movement abilities" function in case we were given a movement Relic.
    0x28, 0x48,  # ldr  r0, 0x80290C0
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # add  r3, 0x05
    0x9E, 0x46,  # mov  r14, r3
    0x87, 0x46,  # mov  r15, r0
    # Add sixty frames (1 second) to the delay timer.
    0x1B, 0x48,  # ldr  r0, 0x2018A00
    0x3C, 0x21,  # mov  r1, 0x3C
    0x01, 0x81,  # strh r1, [r0, 0x08]
    # Check our center textbox buffer for a non-zero number. If we have one, run the "display gray center-of-screen
    # textbox" function with that number in r1 and 0xE in r2.
    0x19, 0x4A,  # ldr  r2, 0x2018A00
    0x51, 0x88,  # ldrh r1, [r2, 0x02]
    0x00, 0x29,  # cmp  r1, 0x00
    0x0F, 0xD0,  # beq  [forward 0x10]
    0x0E, 0x22,  # mov  r2, 0x0E
    0x19, 0x48,  # ldr  r0, 0x802B4E4
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # add  r3, 0x05
    0x9E, 0x46,  # mov  r14, r3
    0x87, 0x46,  # mov  r15, r0
    # Run the "update movement abilities" function in case we were given a movement Relic.
    0x1F, 0x48,  # ldr  r0, 0x80290C0
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # add  r3, 0x05
    0x9E, 0x46,  # mov  r14, r3
    0x87, 0x46,  # mov  r15, r0
    # Add two frames to the delay timer and prime the textbox for deletion upon regaining control.
    0x12, 0x48,  # ldr  r0, 0x2018A00
    0x02, 0x21,  # mov  r1, 0x02
    0x01, 0x81,  # strh r1, [r0, 0x08]
    0x01, 0x21,  # mov  r1, 0x01
    0x81, 0x72,  # strb r1, [r0, 0x0A]
    # Check our max up buffer for a non-zero number. If we have one, run the "call max up graphic" function with that
    # number minus 1 in r0.
    0x0F, 0x48,  # ldr  r0, 0x2018A00
    0xC0, 0x7A,  # ldrb r0, [r0, 0x0B]
    0x00, 0x28,  # cmp  r0, 0x00
    0x05, 0xD0,  # beq  [forward 0x06]
    0x01, 0x38,  # sub  r0, 0x01
    0x17, 0x4A,  # ldr  r2, 0x801A8B0
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # add  r3, 0x05
    0x9E, 0x46,  # mov  r14, r3
    0x97, 0x46,  # mov  r15, r2
    # Increase the "received item index" by the specified number in our "item index amount to increase" buffer.
    0x0A, 0x48,  # ldr  r0, 0x2018A00
    0x83, 0x88,  # ldrh r3, [r0, 0x04]
    0x0E, 0x4A,  # ldr  r2, 0x2028872
    0x11, 0x88,  # ldrh r1, [r2]
    0xC9, 0x18,  # add  r1, r1, r3
    0x11, 0x80,  # strh r1, [r2]
    # Check our "sound effect ID" buffer and run the "play sound" function if it's a non-zero number.
    0xC0, 0x88,  # ldrh r0, [r0, #6]
    0x00, 0x28,  # cmp  r0, #0
    0x04, 0xD0,  # beq  [forward 0x05]
    0x0A, 0x4A,  # ldr  r2, 0x80BB120
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # add  r3, 0x05
    0x9E, 0x46,  # mov  r14, r3
    0x97, 0x46,  # mov  r15, r2
    # Clear all our buffers and return to the "check for player inputs" function we've hooked into.
    0x03, 0x48,  # ldr  r0, 0x2018A00
    0x00, 0x21,  # mov  r1, #0
    0x01, 0x60,  # str  r1, [r0]
    0x41, 0x60,  # str  r1, [r0, 0x04]
    0xC1, 0x72,  # strb r1, [r0, 0x0B]
    0x31, 0xBC,  # pop  r0, r4, r5
    0x03, 0x4A,  # ldr  r2, 0x8007554
    0x97, 0x46,  # mov  r15, r2
    # LDR number pool
    0x00, 0x8A, 0x01, 0x02,
    0x80, 0x89, 0x00, 0x08,
    0xE4, 0xB4, 0x02, 0x08,
    0x54, 0x75, 0x00, 0x08,
    0x20, 0xB1, 0x0B, 0x08,
    0x72, 0x88, 0x01, 0x02,
    0xDC, 0xB5, 0x02, 0x08,
    0x48, 0x00, 0x00, 0x02,
    0x38, 0xAF, 0x00, 0x08,
    0x00, 0x00, 0x00, 0x02,
    0xB0, 0xA8, 0x01, 0x08,
    0xC0, 0x90, 0x02, 0x08
]

furniture_pickup_customizer = [
    # Blocks putting furniture with an index higher than 0x1E in the inventory upon picking one up; all furniture with
    # an index higher than that are AP off-world items. In addition, if the index is 0x21 (our AP Trap item), the pickup
    # sound effect will be changed to a specific "trap" sound.
    0x10, 0xB4,  # push r4
    0x0C, 0x1C,  # add  r4, r1, 0x00
    0x01, 0x40,  # and  r1, r0
    0x01, 0x20,  # mov  r0, 0x01
    0x88, 0x40,  # lsl  r0, r1
    0x11, 0x78,  # ldrb r1, [r2]
    0x04, 0xB4,  # push r2
    0x21, 0x2C,  # cmp  r4, 0x21
    0x01, 0xD1,  # bne  [forward 0x02]
    0x8F, 0x22,  # mov  r2, 0x8F
    0x90, 0x46,  # mov  r2, r8
    0x03, 0x4B,  # ldr  r3, 0x801A1D8
    0x1E, 0x2C,  # cmp  r4, 0x1E
    0x00, 0xDD,  # ble  [forward 0x01]
    0x04, 0x33,  # add  r3, 0x04
    0x14, 0xBC,  # pop  r2, r4
    0x9F, 0x46,  # mov  r15, r3
    0x00, 0x00,
    # LDR number pool
    0xD8, 0xA1, 0x01, 0x08,
]

start_inventory_giver = [
    # When the player create function runs upon starting a new game, this will give the player their entire start
    # inventory. Item/equipment counts, relics, etc. will be copied into their respective inventories.

    # Also handles anything extra that should be done upon file creation, like setting any additional flags.
    0xA0, 0x84,  # strh r0, [r4, 0x24]
    # Use Items
    0x04, 0x48,  # ldr  r0, 0x20187A0
    0x04, 0x49,  # ldr  r1, START_INVENTORY_USE_START
    0x00, 0x22,  # mov  r2, 0x00
    0x8B, 0x58,  # ldr  r3, [r1, r2]
    0x83, 0x50,  # str  r3, [r0, r2]
    0x04, 0x32,  # add  r2, 0x04
    0x1C, 0x2A,  # cmp  r2, 0x1C
    0xFA, 0xDB,  # blt [backward 0x05]
    0x03, 0xE0,  # b   [forward 0x04]
    # LDR number pool
    0xA0, 0x87, 0x01, 0x02,
    0xA0, 0x87, 0x01, 0x02,
    # Equipment
    0x04, 0x48,  # ldr  r0, 0x20187BE
    0x05, 0x49,  # ldr  r1, START_INVENTORY_EQUIP_START
    0x00, 0x22,  # mov  r2, 0x00
    0x8B, 0x5A,  # ldrh r3, [r1, r2]
    0x83, 0x52,  # strh r3, [r0, r2]
    0x02, 0x32,  # add  r2, 0x02
    0x80, 0x2A,  # cmp  r2, 0x80
    0xFA, 0xDB,  # blt [backward 0x05]
    0x04, 0xE0,  # b   [forward 0x05]
    0x00, 0x00,
    # LDR number pool
    0xBE, 0x87, 0x01, 0x02,
    0xBE, 0x87, 0x01, 0x02,
    # Spell Books
    0x03, 0x48,  # ldr  r0, 0x201883E
    0x04, 0x49,  # ldr  r1, START_INVENTORY_BOOK_START
    0x0B, 0x78,  # ldrb r3, [r1]
    0x03, 0x70,  # strb r3, [r0]
    0x4B, 0x78,  # ldrb r3, [r1, 0x01]
    0x03, 0x48,  # ldr  r0, 0x201877F
    0x03, 0x70,  # strb r3, [r0]
    0x05, 0xE0,  # b   [forward 0x06]
    # LDR number pool
    0x3E, 0x88, 0x01, 0x02,
    0x3E, 0x88, 0x01, 0x02,
    0x7F, 0x87, 0x01, 0x02,
    # Relics
    0x05, 0x48,  # ldr  r0, 0x201883F
    0x06, 0x49,  # ldr  r1, START_INVENTORY_RELICS_START
    0x00, 0x22,  # mov  r2, 0x00
    0x8B, 0x5C,  # ldrb r3, [r1, r2]
    0x83, 0x54,  # strb r3, [r0, r2]
    0x80, 0x1C,  # add  r0, r0, 0x02
    0x83, 0x54,  # strb r3, [r0, r2]
    0x80, 0x1E,  # sub  r0, r0, 0x02
    0x01, 0x32,  # add  r2, 0x01
    0x02, 0x2A,  # cmp  r2, 0x02
    0xF7, 0xDB,  # blt [backward 0x08]
    0x03, 0xE0,  # b   [forward 0x04]
    # LDR number pool
    0x3F, 0x88, 0x01, 0x02,
    0x3F, 0x88, 0x01, 0x02,
    # Furniture
    0x04, 0x48,  # ldr  r0, 0x2018843
    0x05, 0x49,  # ldr  r1, START_INVENTORY_FURN_START
    0x00, 0x22,  # mov  r2, 0x00
    0x8B, 0x5C,  # ldrb r3, [r1, r2]
    0x83, 0x54,  # strb r3, [r0, r2]
    0x01, 0x32,  # add  r2, 0x01
    0x04, 0x2A,  # cmp  r2, 0x04
    0xFA, 0xDB,  # blt [backward 0x05]
    0x04, 0xE0,  # b   [forward 0x05]
    0x00, 0x00,
    # LDR number pool
    0x43, 0x88, 0x01, 0x02,
    0x43, 0x88, 0x01, 0x02,
    # Whip attachments
    0x02, 0x48,  # ldr  r0, 0x20187BC
    0x03, 0x49,  # ldr  r1, START_INVENTORY_WHIPS_START
    0x0B, 0x88,  # ldrh r3, [r1]
    0x03, 0x80,  # strh r3, [r0]
    0x04, 0xE0,  # b   [forward 0x05]
    0x00, 0x00,
    # LDR number pool
    0xBC, 0x87, 0x01, 0x02,
    0xBC, 0x87, 0x01, 0x02,
    # Extra HP, MP, and Hearts
    0x08, 0x48,  # ldr  r0, 0x2018786
    0x09, 0x49,  # ldr  r1, START_INVENTORY_MAX_START
    # Max HP
    0x0A, 0x88,  # ldrh r2, [r1]
    0x03, 0x88,  # ldrh r3, [r0]
    0x9B, 0x18,  # add  r3, r3, r2
    0x03, 0x80,  # strh r3, [r0]
    # Max MP
    0x4A, 0x88,  # ldrh r2, [r1, 0x02]
    0x43, 0x88,  # ldrh r3, [r0, 0x02]
    0x9B, 0x18,  # add  r3, r3, r2
    0x43, 0x80,  # strh r3, [r0, 0x02]
    # Max Hearts
    0x8A, 0x88,  # ldrh r2, [r1, 0x04]
    0x83, 0x88,  # ldrh r3, [r0, 0x04]
    0x9B, 0x18,  # add  r3, r3, r2
    0x83, 0x80,  # strh r3, [r0, 0x04]
    # Current Hearts
    0xC3, 0x89,  # ldrh r3, [r0, 0x0E]
    0x9B, 0x18,  # add  r3, r3, r2
    0xC3, 0x81,  # strh r3, [r0, 0x0E]
    0x03, 0xE0,  # b   [forward 0x04]
    # LDR number pool
    0x86, 0x87, 0x01, 0x02,
    0x86, 0x87, 0x01, 0x02,
    # Set the "can see Castle A + B maps" flag.
    0x02, 0x48,  # ldr  r0, 0x200030D
    0x01, 0x78,  # ldrb r1, [r0]
    0x80, 0x22,  # mov  r2, 0x80
    0x11, 0x43,  # orr  r1, r2
    0x01, 0x70,  # ldrb r1, [r0]
    0x01, 0xE0,  # b   [forward 0x02]
    # LDR number pool
    0x0D, 0x03, 0x00, 0x02,
    # Return to the function that gives characters their starting stuff.
    0x03, 0x4B,  # ldr  r3, 0x8494580
    0x19, 0x68,  # ldr  r1, [r3]
    0xE2, 0x8A,  # ldrh r2, [r4, 0x16]
    0x01, 0x48,  # ldr  r0, 0x806B738
    0x87, 0x46,  # mov  r15, r0
    0x00, 0x00,
    # LDR number pool
    0x38, 0xB7, 0x06, 0x08,
    0x80, 0x45, 0x49, 0x08
]

major_pickup_sound_player = [
    # When picking up a piece of equipment, this will check to see if it was JB's Bracelet that was picked up and, if it
    # was, sets the "can warp castles" flag and changes the pickup sound to play to be the "major" sound.
    0x05, 0xB4,  # push r0, r2
    0x3A, 0x20,  # mov  r0, 0x3A
    0x32, 0x5E,  # ldsh r2, [r6, r0]
    0x2A, 0x2A,  # cmp  r2, 0x2A
    0x01, 0xD1,  # bne  [forward 0x02]
    0x36, 0x20,  # mov  r0, 0x36
    0x80, 0x46,  # mov  r8, r0
    0x05, 0xBC,  # pop  r0, r2
    0x4E, 0x30,  # add  r0, 0x4E
    0x82, 0x18,  # add  r2, r0, r2
    0x10, 0x78,  # ldrb r0, [r2]
    0x62, 0x28,  # cmp  r0, 0x62
    0x00, 0x4B,  # ldr  r3, 0x8019F8C
    0x9F, 0x46,  # mov  r15, r3
    # LDR number pool
    0x8C, 0x9F, 0x01, 0x08
]

jb_bracelet_checker = [
    # When the round gate update code runs, this will check to see if JB's Bracelet is equipped or in the inventory. If
    # it is, the "can warp between castles" flag will be set, allowing warping between castles and warping to unvisited
    # warp rooms in the same castle that were visited in the other castle.

    # Check if JB's Bracelet is in the inventory.
    0x01, 0xB4,  # push r0
    0x00, 0x20,  # mov  r0, 0x00
    0x0F, 0x49,  # ldr  r1, 0x20187E8
    0x08, 0x78,  # ldrb r0, [r1]
    0x68, 0x39,  # sub  r1, 0x68
    0x4A, 0x78,  # ldrb r2, [r1, 0x01]
    0x2A, 0x2A,  # cmp  r2, 0x2A
    # Check if JB's Bracelet is in any equipped accessory slot.
    0x00, 0xD1,  # bne  [forward 0x01]
    0x01, 0x30,  # add  r0, 0x01
    0x8A, 0x78,  # ldrb r2, [r1, 0x01]
    0x2A, 0x2A,  # cmp  r2, 0x2A
    0x00, 0xD1,  # bne  [forward 0x01]
    0x01, 0x30,  # add  r0, 0x01
    0xCA, 0x78,  # ldrb r2, [r1, 0x01]
    0x2A, 0x2A,  # cmp  r2, 0x2A
    0x00, 0xD1,  # bne  [forward 0x01]
    0x01, 0x30,  # add  r0, 0x01
    # If JB's Bracelet was in any of the above, set the "can warp between castles" flag. Otherwise, un-set it.
    0x07, 0x49,  # ldr  r1, 0x200031B
    0x0A, 0x78,  # ldrb r2, [r1]
    0x00, 0x28,  # cmp  r0, 0x00
    0x02, 0xD1,  # bne   [forward 0x03]
    0xDF, 0x23,  # mov  r3, 0xDF
    0x1A, 0x40,  # and  r2, r3
    0x01, 0xE0,  # b     [forward 0x02]
    0x20, 0x23,  # mov  r3, 0x20
    0x1A, 0x43,  # orr  r2, r3
    0x0A, 0x70,  # strb r2, [r1]
    # Go to and run the round gate's regular update code like normal.
    0x01, 0xBC,  # pop r0
    0x00, 0x4B,  # ldr  r3, 0x801BB58
    0x9F, 0x46,  # mov  r15, r3
    # LDR number pool
    0x58, 0xBB, 0x01, 0x08,
    0x1B, 0x03, 0x00, 0x02,
    0xE8, 0x87, 0x01, 0x02,
]

cross_castle_warp_blocker = [
    # Blocks usage of the warp room cross-castle warp gates if the player doesn't have the cross-castle condition
    # satisfied. This is necessary to have due to the change of making said gate always spawn in its closed state.
    0x09, 0x48,  # ldr  r0, 0x200031B
    0x00, 0x78,  # ldrb r0, [r0]
    0x20, 0x21,  # mov  r1, 0x20
    0x08, 0x40,  # and  r0, r1
    0x00, 0x28,  # cmp  r0, 0x00
    0x01, 0xD1,  # bne  [forward 0x02]
    0x05, 0x49,  # ldr  r1, 0x801BCB8
    0x8F, 0x46,  # mov  r15, r1
    0x03, 0x49,  # ldr  r1, 0x0001848C
    0x58, 0x18,  # add  r0, r3, r1
    0x02, 0x68,  # ldr  r2, [r0]
    0x90, 0x7A,  # ldrb r0, [r2, 0x0A]
    0x00, 0x49,  # ldr  r1, 0x801BC3C
    0x8F, 0x46,  # mov  r15, r1
    # LDR number pool
    0x3C, 0xBC, 0x01, 0x08,
    0x8C, 0x84, 0x01, 0x00,
    0xB8, 0xBC, 0x01, 0x08,
    0x1B, 0x03, 0x00, 0x02,
]

unvisited_warp_destination_blocker = [
    # Normally, when warping from one warp room to a different one in the current castle, if the player has been in the
    # destination warp room in the other castle, they will be warped to that room in the current castle regardless of
    # whether they've actually been in it in the current castle or not. This will prevent that if the cross-castle warp
    # condition is not satisfied yet, continuing the destination search loop if the player hasn't been to the chosen
    # destination room in the castle they are currently in.
    0x00, 0x00,
    0x10, 0x48,  # ldr  r0, 0x200031B
    0x00, 0x78,  # ldrb r0, [r0]
    0x20, 0x21,  # mov  r1, 0x20
    0x08, 0x40,  # and  r0, r1
    0x00, 0x28,  # cmp  r0, 0x00
    0x0F, 0xD1,  # bne  [forward 0x10]
    0x31, 0x1C,  # add  r1, r6, 0x00
    0x44, 0x31,  # add  r1, 0x44
    0x89, 0x18,  # add  r1, r1, r2
    0x0C, 0x48,  # ldr  r0, 0x2000070
    0x00, 0x78,  # ldrb r0, [r0]
    0x01, 0x22,  # mov  r2, 0x01
    0x10, 0x40,  # and  r0, r2
    0x00, 0x28,  # cmp  r0, 0x00
    0x00, 0xD0,  # beq  [forward 0x01]
    0x04, 0x31,  # add  r1, 0x04
    0x08, 0x68,  # ldr  r0, [r1]
    0x18, 0x40,  # and  r0, r3
    0x00, 0x28,  # cmp  r0, 0x00
    0x01, 0xD1,  # bne  [forward 0x02]
    0x05, 0x4B,  # ldr  r3, 0x8009BD4
    0x9F, 0x46,  # mov  r15, r3
    0x40, 0x46,  # mov  r0, r8
    0x01, 0x78,  # ldrb r1, [r0]
    0xC9, 0x07,  # lsl  r1, r1, 0x1F
    0xC9, 0x0F,  # lsr  r1, r1, 0x1F
    0x89, 0x00,  # lsl  r1, r1, 0x02
    0x00, 0x4B,  # ldr  r3, 0x8009C38
    0x9F, 0x46,  # mov  r15, r3
    # LDR number pool
    0x38, 0x9C, 0x00, 0x08,
    0xD4, 0x9B, 0x00, 0x08,
    0x1B, 0x03, 0x00, 0x02,
    0x70, 0x00, 0x00, 0x02
]

start_spawn_setter = [
    # While saving (through either a save room or the pause menu), if the player is holding down R, their map spawn
    # coordinates will be set to 0E 17 (the first interior room of Entrance A) instead of wherever their last save room
    # save was. Very important feature to have for softlock prevention in the event that the player saves at a save room
    # in a location they cannot return from, like in Castle Treasury A if they made it there through the skull door
    # without double jump with the vanilla area layout.

    # Check if the player is holding R.
    0x01, 0xB4,  # push r0
    0x02, 0x21,  # mov  r1, 0x02
    0x09, 0x06,  # lsl  r1, r1, 0x16
    0x4A, 0x7D,  # ldrb r2, [r1, 0x15]
    0x01, 0x23,  # mov  r3, 0x01
    0x1A, 0x40,  # and  r2, r3
    0x01, 0x2A,  # cmp  r2, 0x01
    0x10, 0xD1,  # bne  [forward 0x11]
    # If they were, set 0E 17 as their spawn coordinates.
    0x03, 0x22,  # mov  r2, 0x03
    0x12, 0x02,  # lsl  r2, r2, 0x08
    0x52, 0x18,  # add  r2, r2, r1
    0x0E, 0x23,  # mov  r3, 0x0E
    0x13, 0x73,  # strb r3, [r2, 0x0C]
    0x17, 0x23,  # mov  r3, 0x17
    # Careful not to un-set the "Castle A + B maps viewable" flags!
    0x50, 0x7B,  # ldrb r0, [r2, 0x0D]
    0xC0, 0x21,  # mov  r1, 0xC0
    0x08, 0x40,  # and  r0, r1
    0x03, 0x43,  # orr  r3, r0
    0x53, 0x73,  # strb r3, [r2, 0x0D]
    # Run the "play sound" function with sound 0x35 to indicate the set was successful.
    0x35, 0x20,  # mov  r0, 0x35
    0x07, 0x4A,  # ldr  r2, 0x80BB120
    0x7B, 0x46,  # mov  r3, r15
    0x05, 0x33,  # add  r3, 0x05
    0x9E, 0x46,  # mov  r14, r3
    0x97, 0x46,  # mov  r15, r2
    # Return to the save function like normal.
    0x01, 0xBC,  # pop  r0
    0x03, 0x4F,  # ldr  r7, 0x8494580
    0xF0, 0x01,  # lsl  r0, r6, 0x07
    0x80, 0x1B,  # sub  r0, r0, r6
    0xC5, 0x00,  # lsl  r5, r0, 0x03
    0x00, 0x4B,  # ldr  r3, 0x800BA60
    0x9F, 0x46,  # mov  r15, r3
    # LDR number pool
    0x60, 0xBA, 0x00, 0x08,
    0x80, 0x45, 0x49, 0x08,
    0x20, 0xB1, 0x0B, 0x08
]

extra_item_sprites = {
    # The GFX data for any inserted extra item sprites, including the Archipelago Items. Graphics in this game are
    # arranged very differently from how they are in Circle of the Moon, with each VRAM tile row being separated out in
    # a way that makes it easier to see in a standard VRAM viewer instead of just every row grouped with the sprite.

    # NOTE: The Archipelago logo is Â© 2022 by Krista Corkos and Christopher Wilson
    # and licensed under Attribution-NonCommercial 4.0 International.
    # See LICENSES.txt at the root of this apworld's directory for more licensing information.

    # Archipelago Filler top half
    0xEF794: [0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x30, 0x44, 0x00, 0x33, 0x43, 0x44, 0x30, 0x66, 0x36, 0x44,
              0x63, 0x66, 0x63, 0x43, 0x63, 0x66, 0x66, 0x43, 0x63, 0x33, 0x63, 0x33, 0x30, 0xEE, 0x3E, 0x00,
              0x03, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x43, 0x33, 0x03, 0x00, 0x34, 0xCC, 0x3C, 0x00,
              0xC3, 0xCC, 0xC3, 0x03, 0xC3, 0xCC, 0xCC, 0x03, 0xC3, 0x33, 0xC3, 0x03, 0x30, 0x99, 0x39, 0x00],
    # Archipelago Progression top half
    0xEF7D4: [0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x30, 0x44, 0x00, 0x33, 0x43, 0x44, 0x30, 0x66, 0x36, 0x44,
              0x63, 0x66, 0x63, 0x43, 0x63, 0x66, 0x66, 0x43, 0x63, 0x33, 0x63, 0x33, 0x30, 0xEE, 0x3E, 0x00,
              0x03, 0xF0, 0x00, 0x00, 0x34, 0x5F, 0x0F, 0x00, 0xF3, 0x55, 0xF5, 0x00, 0x5F, 0x55, 0x55, 0x0F,
              0xFF, 0x55, 0xF5, 0x0F, 0xF3, 0x55, 0xF5, 0x03, 0xF3, 0xFF, 0xFF, 0x03, 0x30, 0x99, 0x39, 0x00],
    # Archipelago Filler bottom half
    0xEF994: [0xE3, 0xEE, 0xE3, 0x03, 0xE3, 0xEE, 0xEE, 0x33, 0xE3, 0xEE, 0x3E, 0x55, 0x30, 0xEE, 0x53, 0x55,
              0x00, 0x33, 0x53, 0x55, 0x00, 0x00, 0x53, 0x55, 0x00, 0x00, 0x30, 0x55, 0x00, 0x00, 0x00, 0x33,
              0x93, 0x99, 0x93, 0x03, 0x93, 0x99, 0x99, 0x03, 0x35, 0x99, 0x99, 0x03, 0x53, 0x93, 0x39, 0x00,
              0x55, 0x33, 0x03, 0x00, 0x55, 0x03, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00],
    # Archipelago Progression bottom half
    0xEF9D4: [0xE3, 0xEE, 0xE3, 0x03, 0xE3, 0xEE, 0xEE, 0x33, 0xE3, 0xEE, 0x3E, 0x55, 0x30, 0xEE, 0x53, 0x55,
              0x00, 0x33, 0x53, 0x55, 0x00, 0x00, 0x53, 0x55, 0x00, 0x00, 0x30, 0x55, 0x00, 0x00, 0x00, 0x33,
              0x93, 0x99, 0x93, 0x03, 0x93, 0x99, 0x99, 0x03, 0x35, 0x99, 0x99, 0x03, 0x53, 0x93, 0x39, 0x00,
              0x55, 0x33, 0x03, 0x00, 0x55, 0x03, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00],
    # Archipelago Useful top half
    0xEFA14: [0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x30, 0x44, 0x00, 0x33, 0x43, 0x44, 0x30, 0x66, 0x36, 0x44,
              0x63, 0x66, 0x63, 0x43, 0x63, 0x66, 0x66, 0x43, 0x63, 0x33, 0x63, 0x33, 0x30, 0xEE, 0x3E, 0x00,
              0x03, 0xEE, 0x0E, 0x00, 0x34, 0xDE, 0x0E, 0x00, 0xEE, 0xDE, 0xEE, 0x0E, 0xDE, 0xDD, 0xDD, 0x0E,
              0xEE, 0xDE, 0xEE, 0x0E, 0xC3, 0xDE, 0xCE, 0x03, 0xC3, 0xEE, 0xCE, 0x03, 0x30, 0x99, 0x39, 0x00],
    # Archipelago Progression + Useful top half
    0xEFA54: [0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x30, 0x44, 0x00, 0x33, 0x43, 0x44, 0x30, 0x66, 0x36, 0x44,
              0x63, 0x66, 0x63, 0x43, 0x63, 0x66, 0x66, 0x43, 0x63, 0x33, 0x63, 0x33, 0x30, 0xEE, 0x3E, 0x00,
              0x03, 0xF0, 0x00, 0x00, 0x34, 0x5F, 0x0F, 0x00, 0xF3, 0x55, 0xF5, 0x00, 0x5F, 0x55, 0x55, 0x0F,
              0xFF, 0x55, 0xF5, 0x0F, 0xF3, 0x55, 0xF5, 0x03, 0xF3, 0xFF, 0xFF, 0x03, 0x30, 0x99, 0x39, 0x00],
    # Archipelago Trap top half
    0xEFA94: [0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x30, 0x44, 0x00, 0x33, 0x43, 0x43, 0x30, 0x66, 0x36, 0x44,
              0x63, 0x63, 0x66, 0x43, 0x63, 0x66, 0x66, 0x43, 0x63, 0x33, 0x63, 0x33, 0x30, 0xEE, 0x3E, 0x00,
              0x03, 0xF0, 0x00, 0x00, 0x34, 0x5F, 0x0F, 0x00, 0xF4, 0x55, 0xF5, 0x00, 0x5F, 0x55, 0x55, 0x0F,
              0xFF, 0x55, 0xF5, 0x0F, 0xF3, 0x55, 0xF5, 0x03, 0xF3, 0xFF, 0xFF, 0x03, 0x30, 0x99, 0x39, 0x00],
    # Archipelago Useful bottom half
    0xEFC14: [0xE3, 0xEE, 0xE3, 0x03, 0xE3, 0xEE, 0xEE, 0x33, 0xE3, 0xEE, 0x3E, 0x55, 0x30, 0xEE, 0x53, 0x55,
              0x00, 0x33, 0x53, 0x55, 0x00, 0x00, 0x53, 0x55, 0x00, 0x00, 0x30, 0x55, 0x00, 0x00, 0x00, 0x33,
              0x93, 0x99, 0x93, 0x03, 0x93, 0x99, 0x99, 0x03, 0x35, 0x99, 0x99, 0x03, 0x53, 0x93, 0x39, 0x00,
              0x55, 0x33, 0x03, 0x00, 0x55, 0x03, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00],
    # Archipelago Progression + Useful bottom half
    0xEFC54: [0xE3, 0xEE, 0xE3, 0x03, 0xE3, 0xEE, 0xEE, 0x33, 0xE3, 0xEE, 0x3E, 0x55, 0x30, 0xEE, 0x53, 0x55,
              0x00, 0x33, 0x53, 0x55, 0x00, 0x00, 0x53, 0x55, 0x00, 0x00, 0x30, 0x55, 0x00, 0x00, 0x00, 0x33,
              0x93, 0x99, 0x93, 0x03, 0x93, 0xEE, 0x9E, 0x03, 0x35, 0xDE, 0x9E, 0x03, 0xEE, 0xDE, 0xEE, 0x0E,
              0xDE, 0xDD, 0xDD, 0x0E, 0xEE, 0xDE, 0xEE, 0x0E, 0x35, 0xDE, 0x0E, 0x00, 0x03, 0xEE, 0x0E, 0x00],
    # Archipelago Trap bottom half
    0xEFC94: [0xE3, 0xE3, 0xEE, 0x03, 0xE3, 0xEE, 0xEE, 0x33, 0xE3, 0xEE, 0x3E, 0x55, 0x30, 0xEE, 0x53, 0x53,
              0x00, 0x33, 0x53, 0x55, 0x00, 0x00, 0x53, 0x55, 0x00, 0x00, 0x30, 0x55, 0x00, 0x00, 0x00, 0x33,
              0x93, 0x93, 0x99, 0x03, 0x93, 0x99, 0x99, 0x03, 0x35, 0x99, 0x99, 0x03, 0x55, 0x93, 0x39, 0x00,
              0x55, 0x33, 0x03, 0x00, 0x55, 0x03, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00]
}
